<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8"/>

  <title>Abandon Jenkins for Great Good!</title>
  <meta name="description" content="Reducing CI cost (both in time and money) with Bitrise (or anything)."/>
  <meta name="author" content="Artur Dryomov"/>

  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <link rel="stylesheet" href="/css/style.css"/>
  <link rel="stylesheet" href="/css/syntax-highlighting.css"/>

  
  <meta name="theme-color" content="#1e2327">

  </head>

<body>

<header>
<nav>
  <ul>
    
    <li class="menu-left"><a href="/">Posts</a></li>
    
    
    <li class="menu-right"><a href="feed://arturdryomov.dev/index.xml">RSS</a></li>
    
    <li class="menu-right"><a href="https://github.com/arturdryomov">GitHub</a></li>
    
  </ul>
</nav>

</header>

<br/>


<div class="meta">

  <h1><span class="title">Abandon Jenkins for Great Good!</span></h1>
  <h3>December 9, 2018</h3>

</div>

<main>
<p>CI and CD techniques are a part of all good happened to the software development.
Having CI in place means better productivity and higher confidence
in the result of the everyday work. Sounds kind of obvious, right?
Well, let’s take a look at
<a href="https://en.wikipedia.org/wiki/The_Dark_Side_of_the_Moon">the dark side of the Moon</a>.</p>
<p>Do you have a person on the team who occasionally curses Gradle or (and) Maven,
Android SDK or (and) NDK? Maybe someone who knows everything about
these weird Shell scripts you have in the repository? You know, the one
who doesn’t like mentions about broken nightly builds, looks at the <code>htop</code>
from time to time? Yeah, the tooling person. The fancy name nowadays
is a Developer Experience Engineer. Right. The question is — do you want to be
this person? No worries — I already know the answer.</p>
<h1 id="nope">Nope</h1>
<p><a href="https://knowyourmeme.com/memes/this-is-fine">This is fine</a>.
Not a lot of people want to be occupied with fighting constant fires.
It is a special skill of knowing
how things work, preferably from different angles — from Linux kernel IO API
to VCS hooks. The development process involves a lot of tools and issues
might arise from each one of them. Gradle compile times suffer?
Need to profile, compare different Gradle versions, check build scripts,
analyze Java and Kotlin compilers and find out that it was
a <a href="https://lkml.org/lkml/2018/11/19/37">Linux kernel feature</a> or a SSD failure.
Sounds fun, right? Don’t get me started on how much time these things consume.
Imagine a weird code issue which takes hour after hour and multiply
it by a factor of uncontrolled external tools and environments.</p>
<blockquote>
<p>&#x26a0;&#xfe0f; I have to note this explicitly — I’m describing a situation related to small teams.
Big companies have dedicated units to manage all of this and not a single person.</p></blockquote>
<p>Some people might think it is cool to be that person — the only one who knows
how the toolchain works. Well, it is really not.</p>
<ul>
<li>From a personal perspective, it is either a direct ego booster or
a line into the depression zone (since not a lot of people understand
the work you do).</li>
<li>From a team perspective, this situation is
<a href="https://en.wikipedia.org/wiki/Bus_factor">a bus factor</a> at least.
More importantly — a developer occupied by the infrastructure
is a developer not working on improving the product directly and
sometimes it is more important than maintaining tech.</li>
</ul>
<p>I was this person and it felt&hellip; strange. One day I’ve caught myself
on a realization that I hadn’t written a single line of product-related code
for a week. That’s when I’ve started to question myself and the work I do.
Does it really matter for the product or for my coworkers productivity?
What is the point of all this? Can it be optimized without losing benefits?</p>
<p>The first part of the solution was
<a href="https://arturdryomov.dev/posts/do-androids-dream-of-ui-testing/">rethinking UI tests</a>.
The second one was related to&hellip;</p>
<h1 id="jenkins">Jenkins</h1>
<p>It is perfect for scalable environments. Open source,
plugin system, both declarative and GUI configuration, artifacts storage,
battle-tested, familiar across the board and so much more.</p>
<p>There is a catch though — someone has to maintain it. Even the simplest
setup — with only a couple of plugins — will eventually break
(after a minor version update of course).</p>
<ul>
<li>Some Unicode characters in a Git branch name might break a workspace cleanup
procedure for all jobs since weird internal Java methods do that instead
of <code>rm</code>.</li>
<li>Fetching a specific Git <code>refspec</code> might stop working since <code>git fetch</code>
is done in a weird way.</li>
<li>Long pull request descriptions might break the cloning procedure because
<em>argument list is too long</em> or whatever.</li>
</ul>
<p>Basically every plugin update might break something. At the same time
it is hard to ignore them because a lot include Security Issue warnings.
Frequent security issues is not a good sign for any more or less serious system,
but we’ll leave it for now.</p>
<p>Oh, and do not forget that Jenkins needs to be run somewhere.
Amazon AWS helps but still — someone has to maintain it.
And there is no isolation out of the box. Need to cache something across
jobs? Either install globally (and suffer consequences) or reinvent
a Docker-driven wheel over and over again.</p>
<p>Jenkins is a DIY product — it is the main strength and the main weakness
at the same time.</p>
<h1 id="delegate">Delegate</h1>
<p>Human nature pushes us to be responsible for our own lives. At the same time&hellip;</p>
<blockquote>
<p>Human beings are generally not capable of managing more than six to ten people,
particularly when things go sideways and inevitable contingencies arise.</p>
<p>— <em><a href="https://www.amazon.com/dp/B00VE4Y0Z2">Extreme Ownership</a></em></p></blockquote>
<p>The same can be applied to the tools we use. There is a limit on how many
things a small development team can manage on its own without losing
the primary goal — to improve the business value of a product.</p>
<p>Fortunately enough, talking about CI, there is a variety of options to delegate
this task:
<a href="https://travis-ci.org/">Travis</a>,
<a href="https://circleci.com/">Circle</a>,
<a href="https://www.bitrise.io/">Bitrise</a> and more.</p>
<ul>
<li>The maintenance is done not by a team itself but a dedicated unit.
Not the same thing as a unit in the same company though —
it will be necessary to adapt to the CI platform instead of adapting
the platform for the team. At the same time, there are benefits of a free
market. Not satisfied with the platform — move to another one.</li>
<li>Surprisingly it is actually cheaper than having an in-house solution.
Jenkins does not automatically start and stop itself. That means
always working server which results in whooping Amazon AWS bills.
Dedicated services optimize costs via starting and stopping isolated
containers on demand.</li>
</ul>
<h1 id="bitrise">Bitrise</h1>
<p>It was a natural choice for the team because it is the only service that works
with <a href="https://www.atlassian.com/software/bitbucket/server">Bitbucket Server</a>
(<a href="https://confluence.atlassian.com/confeval/development-tools-evaluator-resources/bitbucket/bitbucket-cloud-vs-server">not the same thing as the cloud version</a>).
Interesting fact — Bitbucket Server support
<a href="https://github.com/bitrise-io/bitrise-webhooks/pull/67">was added by an open source contributor</a>.
It is possible because Bitrise components are <a href="https://github.com/bitrise-io">open source</a>.</p>
<p><a href="https://www.bitrise.io/pricing">Pricing is reasonable</a>. I like that
the hardware configuration is not hidden away from customers.
At the same time there is an opt-in for machines with better specs.
For some reason a lot of services hide that kind of information and do not
allow to upgrade the hardware. I was told that Linux machines are provided
via Google Compute Engine. Amazon instances for Jenkins costed us $1000
a month, Bitrise costs $360 for basically the same hardware.
Plus no human resources to support Jenkins!</p>
<p>Since Bitrise people understand that caching is important for shorter
build times there is a multi-level configurable caching. For Android projects
basically everything <code>sdkmanager</code> provides is bundled into the underlying
Docker image — I haven’t seen a single issue with missing SDK packages.
At the same time, it is possible to reuse files across builds, which can
be adapted to include Gradle build cache, dependencies — you name it.</p>
<p>Of course the configuration is declarative and understandable.
There is no need to be a DevOps to read it.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">trigger_map</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">tag</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;v*&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">workflow</span><span class="p">:</span><span class="w"> </span><span class="l">release</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">workflows</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">release</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">steps</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">git-clone</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">title</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Clone Git repository.&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">cache-pull</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">title</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Pull cache.&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">script</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">title</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Run.&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">inputs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">content</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;bash ci/jobs/release.sh&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">deploy-to-bitrise-io</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">title</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Attach artifacts.&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">is_always_run</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">inputs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">deploy_path</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;artifacts/&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">is_enable_public_page</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span></code></pre></div><p>The transition from Jenkins to Bitrise was seamless. For a while we used
both in parallel and after a month I’ve quetly shut down Jenkins with no
consequences for the team.</p>
<h1 id="adapt">Adapt</h1>
<p>We stumble upon a lot of things every day. The tricky part is habit.
Hitting the same thing over and over again eventually will become familiar.
This can lead to unforeseen consequences — like using Jenkins when it is not
really necessary. Do not be afraid to change things. Mutations and selection
formed the human race as it is right now. Who said it cannot form
the best workflow for the team?</p>
<hr>
<p>Title is a reference to the wonderful
<a href="http://learnyouahaskell.com/">Lean You a Haskell for Great Good!</a>.</p>
<hr>
<p>Thanks to <a href="https://twitter.com/artem_zin">Artem Zinnatullin</a> for the review!</p>

</main>


<hr/>

<footer>
<nav>
  <ul>
    
    <li class="menu-left"><a href="/">Posts</a></li>
    
    
    <li class="menu-right"><a href="feed://arturdryomov.dev/index.xml">RSS</a></li>
    
    <li class="menu-right"><a href="https://github.com/arturdryomov">GitHub</a></li>
    
  </ul>
</nav>

</footer>


</body>

</html>

