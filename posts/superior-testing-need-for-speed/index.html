<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8"/>

  <title>Superior Testing: Need for Speed</title>
  <meta name="description" content="I feel the need â€”Â the need for speed!"/>
  <meta name="author" content="Artur Dryomov"/>

  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <link rel="stylesheet" href="/css/style.css"/>
  <link rel="stylesheet" href="/css/syntax-highlighting.css"/>

  
  <meta name="theme-color" content="#1e2327">

  </head>

<body>

<header>
<nav>
  <ul>
    
    <li class="menu-left"><a href="/">Posts</a></li>
    
    
    <li class="menu-right"><a href="feed://arturdryomov.dev/index.xml">RSS</a></li>
    
    <li class="menu-right"><a href="https://github.com/arturdryomov">GitHub</a></li>
    
  </ul>
</nav>

</header>

<br/>


<div class="meta">

  <h1><span class="title">Superior Testing: Need for Speed</span></h1>
  <h3>April 30, 2019</h3>

</div>

<main>
<p>Everybody wants to have a faster development cycle.
Everything should be flawless and straightforward.
Nobody wants to have hour-long builds and stuck CI queues.
We need results! Now! Or maybe even in the past, preemptively.
<a href="https://github.com/guard/guard">Guard</a> from the Ruby ecosystem comes to mind,
starting tests on file changes, without doing it manually.</p>
<p>Talking about tests â€”Â they are a part of the cycle, right?
We run them both locally and remotely (as part of a CI pipeline).
It takes time and I think <a href="https://www.youtube.com/watch?v=SLILjDx0SO0">we can do better</a>!</p>
<h1 id="execute-in-parallel">Execute in Parallel</h1>
<p>A lot of people are familiar with <a href="https://docs.gradle.org/current/userguide/multi_project_builds.html#sec:parallel_execution">the <code>--parallel</code> flag</a>.
It will execute Gradle tasks in parallel, not much else.
<a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:maxParallelForks">We can do the same with tests</a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="n">tasks</span><span class="p">.</span><span class="n">withType</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">maxParallelForks</span> <span class="p">=</span> <span class="nc">Runtime</span><span class="p">.</span><span class="n">getRuntime</span><span class="p">().</span><span class="n">availableProcessors</span><span class="p">()</span> <span class="p">/</span> <span class="m">2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The <code>maxParallelForks</code> default value is <code>1</code>. Give it a bigger number and Gradle
will execute test classes (not methods) in parallel. The snippet above
uses a half of available CPU cores. Results:</p>
<table>
<thead>
<tr>
<th><code>maxParallelForks</code></th>
<th><code>testDebugUnitTest</code> time, seconds</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>53</td>
</tr>
<tr>
<td>4</td>
<td>41</td>
</tr>
</tbody>
</table>
<h1 id="kill-reports">Kill Reports</h1>
<p>Gradle test execution ends in generating at least two sets of reports â€”
JUnit XML and HTML. There is a chance that a CI system of choice uses
at least one of them to render results on UI.
But a lot of systems do not use it at all. Moreover, there is
a good chance that developers do not use these reports at all.
<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/reporting/Report.html#setEnabled-boolean-">Letâ€™s nuke them</a>!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="n">tasks</span><span class="p">.</span><span class="n">withType</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reports</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">report</span> <span class="o">-&gt;</span> <span class="n">report</span><span class="p">.</span><span class="n">isEnabled</span> <span class="p">=</span> <span class="k">false</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th><code>report.isEnabled</code></th>
<th><code>testDebugUnitTest</code> time, seconds</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>true</code></td>
<td>41</td>
</tr>
<tr>
<td><code>false</code></td>
<td>40</td>
</tr>
</tbody>
</table>
<p>Well, this is kind of disappointing&hellip; However, there is an interesting
side effect.</p>
<pre tabindex="0"><code>$ find build/reports/tests/testDebugUnitTest -name &#34;*.html&#34; | wc -l
</code></pre><p>The result will be a number of test classes or similar. This number is
the number of files created by the HTML report. Tools like
<a href="https://github.com/buildfoundation/mainframer">Mainframer</a> transfer files
and fewer files â€”Â the better. Most likely the same thing can be applied
to packaging build artifacts during the CI pipeline.</p>
<table>
<thead>
<tr>
<th><code>report.isEnabled</code></th>
<th>Mainframer sync time, seconds</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>true</code></td>
<td>6</td>
</tr>
<tr>
<td><code>false</code></td>
<td>2</td>
</tr>
</tbody>
</table>
<h1 id="kill-android-variants">Kill Android Variants</h1>
<p>Results above reflect the <code>testDebugUnitTest</code> execution.
At the same time there is a good chance that the CI pipeline
executes either <code>test</code> or <code>build</code> (<code>assemble</code> + <code>test</code>) task.
The issue with the <code>test</code> task is that it runs both
<code>testDebugUnitTest</code> and <code>testReleaseUnitTest</code>.
This effectively doubles the execution time.</p>
<table>
<thead>
<tr>
<th>Gradle Task</th>
<th>Execution time, seconds</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>testDebugUnitTest</code></td>
<td>40</td>
</tr>
<tr>
<td><code>testReleaseUnitTest</code></td>
<td>40</td>
</tr>
<tr>
<td><code>test</code></td>
<td>80</td>
</tr>
</tbody>
</table>
<p>But do we even care about the debug variant? We are shipping the release code, right?
Iâ€™m not gonna suggest excluding the <code>testDebugUnitTest</code> as universal advice
since it is a matter of choice. There is the command though:</p>
<pre tabindex="0"><code>$ ./gradlew build --exclude-task testDebugUnitTest
</code></pre><p>BTW Tor Norbye from the Android Studio team
<a href="https://groups.google.com/forum/#!msg/lint-dev/RGTvK_uHQGQ/FjJA12aGBAAJ">suggests</a>
excluding the <code>lintDebug</code> with similar motivation.</p>
<blockquote>
<p>Youâ€™re probably only shipping your release variant,
so you could limit yourself to just running <code>lintRelease</code> and youâ€™re not going to miss much.</p>
</blockquote>
<h1 id="math">Math</h1>
<p>Letâ€™s iterate over what can be done to make tests execution faster, without changing the source code.</p>
<ul>
<li>Parallel execution: reduce from 53 to 41 seconds.</li>
<li>Killing reports: reduce from 41 to 40 seconds, plus reduced Mainframer sync time.</li>
<li>Killing debug Android variant: not letting the number be multiplied by the factor of two.</li>
</ul>
<p>Looks good! Believe me â€”Â it feels even better to do this IRL ðŸ˜‰</p>

</main>


<hr/>

<footer>
<nav>
  <ul>
    
    <li class="menu-left"><a href="/">Posts</a></li>
    
    
    <li class="menu-right"><a href="feed://arturdryomov.dev/index.xml">RSS</a></li>
    
    <li class="menu-right"><a href="https://github.com/arturdryomov">GitHub</a></li>
    
  </ul>
</nav>

</footer>


</body>

</html>

