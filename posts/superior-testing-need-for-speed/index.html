<!doctype html>
<html lang="en-us">
<head>
   <meta charset="utf-8"/>

 <title>Superior Testing: Need for Speed</title>
 <meta name="description" content="I feel the need — the need for speed!"/>
 <meta name="author" content="Artur Dryomov"/>

 <meta name="viewport" content="width=device-width, initial-scale=1"/>

 <link rel="stylesheet" href="/css/style.css"/>
 <link rel="stylesheet" href="/css/syntax-highlighting.css"/>

 

</head>
<body>
  <header>
    <nav>
  <div class="nav-section">
    
    <a href="/">Posts</a>
    
  </div>

  <div class="nav-section" ->
    
    <a href="https://github.com/arturdryomov">GitHub</a>
    
    <a href="feed://arturdryomov.dev/index.xml">RSS</a>
    
  </div>
</nav>

  </header>
  <main>
    
<header class="article-header">
  <h1 class="article-title">Superior Testing: Need for Speed</h1>
  <time datetime="2019-04-30" class="article-subtitle">April 30, 2019</time>
</header>

<article>
<p>Everybody wants to have a faster development cycle.
Everything should be flawless and straightforward.
Nobody wants to have hour-long builds and stuck CI queues.
We need results! Now! Or maybe even in the past, preemptively.
<a href="https://github.com/guard/guard">Guard</a> from the Ruby ecosystem comes to mind,
starting tests on file changes, without doing it manually.</p>
<p>Talking about tests — they are a part of the cycle, right?
We run them both locally and remotely (as part of a CI pipeline).
It takes time and I think <a href="https://www.youtube.com/watch?v=SLILjDx0SO0">we can do better</a>!</p>
<h1 id="execute-in-parallel">Execute in Parallel</h1>
<p>A lot of people are familiar with <a href="https://docs.gradle.org/current/userguide/multi_project_builds.html#sec:parallel_execution">the <code>--parallel</code> flag</a>.
It will execute Gradle tasks in parallel, not much else.
<a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:maxParallelForks">We can do the same with tests</a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="n">tasks</span><span class="p">.</span><span class="n">withType</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">maxParallelForks</span> <span class="p">=</span> <span class="nc">Runtime</span><span class="p">.</span><span class="n">getRuntime</span><span class="p">().</span><span class="n">availableProcessors</span><span class="p">()</span> <span class="p">/</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The <code>maxParallelForks</code> default value is <code>1</code>. Give it a bigger number and Gradle
will execute test classes (not methods) in parallel. The snippet above
uses a half of available CPU cores. Results:</p>
<table>
  <thead>
      <tr>
          <th><code>maxParallelForks</code></th>
          <th><code>testDebugUnitTest</code> time, seconds</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>53</td>
      </tr>
      <tr>
          <td>4</td>
          <td>41</td>
      </tr>
  </tbody>
</table>
<h1 id="kill-reports">Kill Reports</h1>
<p>Gradle test execution ends in generating at least two sets of reports —
JUnit XML and HTML. There is a chance that a CI system of choice uses
at least one of them to render results on UI.
But a lot of systems do not use it at all. Moreover, there is
a good chance that developers do not use these reports at all.
<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/reporting/Report.html#setEnabled-boolean-">Let’s nuke them</a>!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="n">tasks</span><span class="p">.</span><span class="n">withType</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reports</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">report</span> <span class="o">-&gt;</span> <span class="n">report</span><span class="p">.</span><span class="n">isEnabled</span> <span class="p">=</span> <span class="k">false</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><table>
  <thead>
      <tr>
          <th><code>report.isEnabled</code></th>
          <th><code>testDebugUnitTest</code> time, seconds</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>true</code></td>
          <td>41</td>
      </tr>
      <tr>
          <td><code>false</code></td>
          <td>40</td>
      </tr>
  </tbody>
</table>
<p>Well, this is kind of disappointing&hellip; However, there is an interesting
side effect.</p>
<pre tabindex="0"><code>$ find build/reports/tests/testDebugUnitTest -name &#34;*.html&#34; | wc -l
</code></pre><p>The result will be a number of test classes or similar. This number is
the number of files created by the HTML report. Tools like
<a href="https://github.com/buildfoundation/mainframer">Mainframer</a> transfer files
and fewer files — the better. Most likely the same thing can be applied
to packaging build artifacts during the CI pipeline.</p>
<table>
  <thead>
      <tr>
          <th><code>report.isEnabled</code></th>
          <th>Mainframer sync time, seconds</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>true</code></td>
          <td>6</td>
      </tr>
      <tr>
          <td><code>false</code></td>
          <td>2</td>
      </tr>
  </tbody>
</table>
<h1 id="kill-android-variants">Kill Android Variants</h1>
<p>Results above reflect the <code>testDebugUnitTest</code> execution.
At the same time there is a good chance that the CI pipeline
executes either <code>test</code> or <code>build</code> (<code>assemble</code> + <code>test</code>) task.
The issue with the <code>test</code> task is that it runs both
<code>testDebugUnitTest</code> and <code>testReleaseUnitTest</code>.
This effectively doubles the execution time.</p>
<table>
  <thead>
      <tr>
          <th>Gradle Task</th>
          <th>Execution time, seconds</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>testDebugUnitTest</code></td>
          <td>40</td>
      </tr>
      <tr>
          <td><code>testReleaseUnitTest</code></td>
          <td>40</td>
      </tr>
      <tr>
          <td><code>test</code></td>
          <td>80</td>
      </tr>
  </tbody>
</table>
<p>But do we even care about the debug variant? We are shipping the release code, right?
I’m not gonna suggest excluding the <code>testDebugUnitTest</code> as universal advice
since it is a matter of choice. There is the command though:</p>
<pre tabindex="0"><code>$ ./gradlew build --exclude-task testDebugUnitTest
</code></pre><p>BTW Tor Norbye from the Android Studio team
<a href="https://groups.google.com/forum/#!msg/lint-dev/RGTvK_uHQGQ/FjJA12aGBAAJ">suggests</a>
excluding the <code>lintDebug</code> with similar motivation.</p>
<blockquote>
<p>You’re probably only shipping your release variant,
so you could limit yourself to just running <code>lintRelease</code> and you’re not going to miss much.</p>
</blockquote>
<h1 id="math">Math</h1>
<p>Let’s iterate over what can be done to make tests execution faster, without changing the source code.</p>
<ul>
<li>Parallel execution: reduce from 53 to 41 seconds.</li>
<li>Killing reports: reduce from 41 to 40 seconds, plus reduced Mainframer sync time.</li>
<li>Killing debug Android variant: not letting the number be multiplied by the factor of two.</li>
</ul>
<p>Looks good! Believe me — it feels even better to do this IRL &#x1f609;</p>

</article>

  </main>
</body>
</html>
